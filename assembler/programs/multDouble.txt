#---------------------------------

# initialization
.initSP #set stack pointer
LXI HL data #load pointer to first byte of data into HL regs for MOV instruction memory references

#---------------------------------

# load next numbers to multiply
.pos start
CALL LBC_HL
CALL LDE_HL

# if multiplier is zero, assume we have found the end of the numbers to multiply
MVI A 0
ORA B
ORA C
JZ cleanUp

PUSH HL #push pointer to next number pair to stack bc HL register is used to store product
CALL multDouble

# push product and retrieve pointer 
POP DE
PUSH HL
XCHG

JMP start #loop

#---------------------------------

# to make the products easier to find, I am going to move them from the end of RAM to after the data for the program
# I am also going to fix the order so that it lines up with the order of the data

# to start move pointer to end of memory used to store product. This is done by:
# getting the length in bytes of the data by subtracting the start of data pointer from the end of data pointer 
# adding this offset to the start of data pointer ot recreate the end of data pointer 
# divide this offset by two bc there is one product (two bytes) for every two factors (4 bytes total for factors)
#   this is done by clearing the carry bit and rotating right into carry 
# add this offset (the length of memory used to store the prodcuts) to the end of data pointer to get the end of product pointer
# then add the products backwards from this pointer to fix the reverse order from pushing to the stack

.func cleanUp
# remove length of failed factor pair from end of data pointer
#----
DCX HL
DCX HL
DCX HL
DCX HL
#----

#----
LXI DE data #load start of data pointer to DE
CALL negateDouble #make negative
DAD DE #add to end of data pointer to simulate subtraction
XCHG #move data memory length to DE to make room for loading in start of data pointer to HL
#----

# set HL to end of data pointer
#----
LXI HL data #load start of data pointer
DAD DE #add data memory length to get end of data pointer
#----

# clear carry bit
#----
STC 
CMC
#----

MOV B D
MOV C E

# divide data memory length by two with RShift
#----
MOV A E
RAR
MOV E A
MOV A D
RAR
MOV D A
JNC endRShfit
MOV A E
ORI 128
MOV E A
.pos endRShfit
#----

# add to end of data pointer to get end of product memory pointer
DAD DE

# add back in offset of failed factor pair to pointer to ensure seperation between factors and products
INX HL
INX HL
INX HL
INX HL

.pos moveAnswersLoop
#----
MVI A 0 #for (DE = 2 * product count; DE > 0; DE -= 2)
ORA D
ORA E
JZ end

# move two bytes from stack to RAM at pointer and decrement pointer by two
POP BC
CALL SRBC_HL

DCX DE
DCX DE

JMP moveAnswersLoop
#----

.pos end
HLT

#---------------------------------

# HL += 2; BC is loaded by C = *HL and B = *(HL + 1)
.func LBC_HL
MOV C M
INX HL
MOV B M
INX HL
RET

#---------------------------------

# HL += 2; DE is loaded by E = *HL and D = *(HL + 1)
.func LDE_HL
MOV E M
INX HL
MOV D M
INX HL
RET

#---------------------------------

.func SRBC_HL
MOV M B
DCX HL
MOV M C
DCX HL
RET

#---------------------------------

.func SRDE_HL
MOV M D
DCX HL
MOV M E
DCX HL
RET

#---------------------------------

.func XCHG_BC
PUSH DE
MOV E C
MOV D B
POP BC
RET

#---------------------------------

# DE is the double
.func negateDouble
MOV A E
CMA
MOV E A

MOV A D
CMA 
MOV D A

INX DE

#DE = -x; A = floor(x); all other regs are preserved; flags are preserved
RET

#---------------------------------

# double multiplication function
# BC is multiplier and DE is multiplicand
# HL = a * b; A = frac(a); all other regs are preserved; carry bit is set if overflow; all other flags are garbage
.func multDouble
PUSH BC
PUSH DE

MOV A B #A = floor(a)
CALL mult #floor(a) * b
PUSH HL

MOV A C #A = frac(a)
MOV C E #C is a temp reg = frac(b)
MOV E D #E = floor(b)
MVI D 0 #D = 0; therefore, DE = floor(b)
CALL mult #frac(a) * floor(b)
PUSH HL 

MOV E C #E = frac(b)
MVI D 0 #D = 0; therefore, DE = frac(b)
CALL mult #frac(a) * frac(b)

# most significant byte from frac(a) * frac(b) is loaded into least significant register of DE and most significant register is cleared
# this is because frac(a) * frac(b) needs an offset of -2 bytes or -1 byte when you consider the double is already offset -1 byte
MOV E H
MVI D 0

# this is added to the double from frac(a) * floor(b), which is poped off the stack
POP HL
DAD DE

# then the double from floor(a) * b is poped off the stack and added to the sum
POP DE
DAD DE

# reset registers
POP DE
POP BC

# HL = a * b; A = frac(a); all other regs are preserved; carry bit is set if overflow; all other flags are garbage
RET

#---------------------------------

# multiplication function
# A is multiplier and DE is multiplicand
.func mult
PUSH FA
PUSH BC
PUSH DE
LXI HL r0

# init counter
MVI B 8

# for loop
.pos loop

# test LSB of multiplier
RAR
JNC next
# add multiplicand to partial product if one
DAD DE

.pos next
# LShift multiplicand
XCHG 
DAD HL
XCHG

# repeat for loop while counter is > 0 or return when not
DCR B
JNZ loop

# reset registers
POP DE
POP BC
POP FA

# HL = a * b; flags are garbage; all other regs are preserved;
RET

#---------------------------------

r0
r0
r0
r0
r0
r0
r0
r0

.pos data

#----
# 2.5
128
2

# * 3.0
0
3
#----

#----
# 5.25
64
5

# * 7.5
128
7
#----

# program only terminates when 0 * x is detected
r0
r0

# this is where the result will be stored
# the first (most significant) byte of the first product will be two bytes after the last non-zero number pair