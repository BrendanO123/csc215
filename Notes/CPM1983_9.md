# Chapter Nine
## Why do we Have Registers?
 - **Speed**: registers are built into the CPU chip, not external RAM. This means they can be fetched and used far faster than RAM memory, which takes a significant amount of time to load into the CPU.
 - **Portability**: every CP/M computer that our programs will execute on will have the at least as many registers as the 8080 chip. This means we can count on these registers to create more portable programs. 
 - **Multiple Numbers**: most programs will need to work with a few numbers at a time. In order to store multiple numbers as working variables, you need multiple registers to store them in. Even if the programs make use of RAM to store data, they will still need multiple pointers in the registers to keep track of the RAM memory.

## ALU and Register File
The ALU (arithmetic/logic unit) is the component on the CPU that handles all the math and bitwise logic operations. Most of these operations, such as the `ADD` instruction, take in two inputs and produce one output (though some take in less parameters). The ALU always gets its two inputs from the accumulator (`A` register) and an 8-bit data bus that runs across the CPU, which can be written to by the register file or RAM memory. Its output is then routed back onto this bus, and it outputs directly to the [flags register](#flags-register) (`F`) as well. 

This means that all operations that need two parameters need to use the accumulator as one parameter and read the other parameter from the data bus. For registers `B, C, D, E, H, & L`, these can be written directly from the register file to the data bus and used as parameters. For register pair math, such as `DAD DE`, these instructions have to be simulated with 8-bit operations working on one register at a time.

### The `M` "Register"
One important note, the `M` "register" is not actually a physical data register in the register file. When the programmer fetches the `M` register, the contents of the `HL` register pair is written to a 16-bit address bus and is fed into the RAM memory. Then, the RAM memory is fetched at this address and is fed back into the 8-bit data bus, to be used by the register file or ALU. The same thing happens when the programmer stores the data bus to the `M` register. What makes the `M` "register" powerful is that it does not require you to load data into the register file to use it, and can be used to read or write data at the same time you are operating on it.

### Flags Register
In addition to the output, the ALU also writes a special output byte directly to the register file called the flag byte (`F` register). This byte contains 8 boolean values giving information about the result of the operation, which can be used for conditional jump/call functions. Only five of the flag bits are implemented in the 8080 and not all operations set all the flag bits. The five that are implemented are:

|Index|Name|Description|Jump Instructions|
|----|----|----|----|
|0|Carry|Is set if a carry-out or overflow occurs on an addition operation|Jump Carry (JC), Jump Not Carry (JNC)|
|2|Parity|Is set when the number of set bits in a result is even, e.g. 11110000 has 4 set bits and four is even; therefore, the parity bit would be set|Jump Parity Even (JPE), Jump Parity Odd (JPO)|
|4|Aux Carry|Is used by the decimal adjust accumulator instruction and is set under similar circumstances as the carry bit|N/A|
|6|Zero|Is set if the operation resulted in a result of 0|Jump Zero (JZ), Jump Not Zero (JNZ)|
|7|Sign|Is set to the MSB of the result (1 if <0; 0 if >=0)|Jump Plus (JP), Jump Minus (JM)|

Note that the bits at index 3 and 5 are always set to zero and the bit at index 1 is always set to one.

## The Stack
The stack is not actually a set of hardware registers like you might imagine, but is instead just some location in RAM pointed to by the Stack Pointer (SP). Whenever a register pair is pushed to the stack (PUSH), it is placed in RAM in the two addresses preceding the current location of the stack pointer. By default, the Stack Pointer is set to zero on start up, which means that the first register pair is pushed to the indexes -1 and -2, or more reasonably the last addressable memory location ($2^{16} - 1$) and one before it ($2^{16} - 2$). This same process is done in reverse when using the POP instruction to load from the stack, the stack pointer is incremented by two and two bytes are removed from the top of the stack.

The stack is also used by the computer for the CALL and RET functions to serve as a call stack. Whenever the program encounters a call function, it increments the program counter to the next instruction and pushes it to the stack, then it jumps to the address of the call. This allows any subsequent RET functions to simply look up the address on the top of the stack and jump to this location to return normal execution. This is an extremely powerful tool for generating abstraction through functions.
