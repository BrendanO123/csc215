
## Assembly Coding
**Why Use Assembly Coding:** people still use assembly code in applications where speed and minimal executable size is of extreme importance. Assembly code is also still the best option when it comes to intimately interfacing with and understanding the hardware of a system.

**Labels:** labels are plain text words placed before the instruction on a line, which may be referenced by name as memory positions for instructions such as JUMP and CALL to allow for better readability of code.

**Opcodes:** Opcodes are the enumerated machine code instructions that the computer actually understands on a hardware level. All of these instructions come in the form of a mnemonic, such as `HLT`, and the binary opcode, such as `0b01110110`.

Make sure to name your programs appropriately so that you can remember what they do and how to use them.

## The Terminal
The *terminal*, also referenced as a console, screen, monitor and keyboard, CRT, VDT, CON, OR TTY, is the device through which computer users communicate with their computer.

The standard terminal back in these days was the ASR-33 Teletype, about three hundred thousand of these were manufactured back in the days. Because this was so common, all computers came with an interface suitable for the TTY (teletype). This was slowly phased out in favor of cathode ray tube, or CRT, TVs and silent, electronic keyboards. This is often referred to as the CRT Terminal or just CRT for short.


## Mass Storage
### The First Storage Estimates
For the first programs, it was decided that **four thousand words of storage** would be enough to run any conceivable calculation, with each word being **40 bits** long. It is worth noting that this was intended for computation programs only, more complex programs such as games or simulations were not considered.

### The 8080's Storage
The 8080 family of microcomputers, on the other hand, can directly address **64K bytes of RAM and deals only with 8 bit bytes** instead of the originally conceived 40 bit words. Here 64K bytes is actually closer to 65 thousand bytes from the following equation:
$$
\frac{64\text{ (kilobytes)}}{1} * \frac{1024\ =\ 2^{10} \text{ (bytes)}}{1 \text{ (kilobyte)}} \approx 65,000 \text{ (bytes)}
$$

### The Issue with Main Memory
Even though more high-speed main memory storage could be added to the computer, the main memory is limited in an effort to manage the cost of the computer. Instead, lower cost "mass storage," any type of external memory, is used to store more data. Mass storage can be any external memory, such as tapes, floppy disks, drums, or even RAM memory beyond the normal memory address space.

## Disk Addressing
### The Problem
On our C/PM based computer, we will have at least 2-4 disks storing anywhere from 70K bytes to a couple million bytes. When addressing memory inside the main memory of our computer, we can simply use 16-bit numbers to address anywhere in main memory directly. However, addressing memory on the disks is far harder, as using larger and larger pointers to memory addresses is very impractical for these old computers.

### Disk Layouts
Instead, to address to a specific record of data on a disk, we would have to manage the specific track and sector the record is on.
|**Disks**|
|----|
|Contain multiple **Circular Tracks**|
|which are broken into a number of **Sectors**|
|and these are further divided into multiple **128 Byte Records**|
|within these records, is where your **Actual Data** is stored|

### CP/M
Each sector has its own address, such as "Disk A at track 3 and sector 15." However, we do not need to remember these addresses ourselves when working on the CP/M operating system because the operating system can keep track of this for us. Instead, all we have to keep track of is the file name and the drive it is on, CP/M handles the rest. For these computers, all text files are assumed to use ASCII to remain compatible with outside standards.