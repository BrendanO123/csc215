# The File Control Block
## CP/M and Disk IO 
CP/M handles the physical disk data management such as *track x sector y* allowing for named file abstraction with programmatic access.

In order to access disks in our programs, we will still use the BDOS hook at location 5. However, we will need to provide far more information than just a function name, such as WCONF, or a buffer size for RBUFF. To do this, we will also pass a block of RAM known as a File Control Block or FCB. Specifically, for our use cases, we will use the transient FCB or TFCB that CP/M reserves for us from memory location `005CH` to `007CH`. 

## Use of the TFCB
The TFCB tells CP/M how to find a specific file for a disk IO operation and holds room for working variables for CP/M to use in the process. It is also loaded automatically for the program to use when a file name is provided in the execution of a .COM file such as `A:ASM C:FILENAME.TYP`. This would load `A:ASM.COM` into the TPA and the information for `C:FILENAME.TYP` into the TFCB before executing the program.

## Structure of the TFCB
The TFCB contains 33 bytes of memory. When it comes to keeping track of files with File Control Blocks stored on the disk, CP/M drops the last byte and only stores 32 bytes per FCB. 

The first byte contains the disk drive selection byte (`dr`), which signifies which disk drive the file can be found on. If this byte is zero, the currently selected drive will be used. Otherwise, the drive used will correspond to the number in `dr`, with 1 being drive A, 2 being drive B, and so on. 

The next 11 bytes in the TFCB contain the filename and file type without the separating `.`. The filename is 8 bytes and the type is 3 bytes. Short names are padded with spaces and long names are truncated. Therefore, `FILE123.TYP` would be stored as `FILE123 TYP`, with the filename padded to 8 bytes and the period dropped. Although discouraged for read and write operations, any of these characters could be replaced with a wildcard character `?` to help search for files by a part of a file name or file type.

All of the remaining bytes are binary data instead of ASCII and are managed by CP/M. Do not touch these bytes.

Skipping three bytes ahead, the 16th byte at location +15 is the record count, which simply stores the number of 128 byte records that are allocated to the given file across the various disk tracks and sectors. 

This is followed by 16 bytes which each store the address to their own 1K byte groups of records on the disk. This means that CP/M files come in sizes that are strictly multiples of 1 KB. The maximum size for a file would be 16 KB because of this, but CP/M gets around this by making multiple FCBs for one large file and keeping track of them with the extent byte. 

The extent byte is the first byte of those three we just skipped (the other two are just working variables for CP/M), and it is used to differentiate multiple FCBs for the same file when the file exceeds the maximum size that can be stored in one FCB and another must be created. If CP/M needs to write a 17 KB file, it will first write the first 16 KB to the disk and fill up the first FCB with 16 pointers to 16 1 KB memory blocks. Then it will write this FCB to the disk and create a new FCB with the extent byte incremented to one and continue writing the file there.

Finally, the last byte of the TFCB is the current record byte, which tells CP/M where to write the next record. This byte is dropped when the TFCB is written to disk after creating a new file.

